package lc7

import "math"

/*
分析：
乘10，rev=rev*10+digit
模10，digit=x%10
除10, x/=10
不等于0，考虑正负,x!=0
小于最小除10，大于最大除10,32位溢出判断(难点，要理解）
重点在于2^31和2^31-1最大位为2，也就是说如果数字小于10位时不用去考虑越界问题。
等于10位时，只用比较反转后的数字reverse前9位与最大最小值的前9位即可。
因为输入数字为10位时，最高位不可能超过2，就是说反转之后reverse的最低位最大为2，不可能超过7，
所以前9位不超过最大最小值前9位时，第10位（最低位）不存在超过最大最小值最低位的情况，也就自然不用关注最低位了。
时间复杂度：O(log∣x∣)。翻转的次数即x十进制的位数
空间复杂度：O(1)
 */
func reverse(x int) (rev int) {
	for x != 0 {
		//判断rev在反转过程中是否溢出32位
		if rev < math.MinInt32/10 || rev > math.MaxInt32/10 {
			return 0
		}
		digit := x % 10
		x /= 10
		rev = rev * 10 + digit
	}
	return rev
}